# -*- coding: utf-8 -*-
"""style transfer nlp

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AKL101h-4IUUOXbJTOiEDVDzAD5IDngz
"""

!pip install pyngrok

!pip install google-generativeai

!pip install nltk

!pip install streamlit

!pip install textstat

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st
# import google.generativeai as genai
# from sentence_transformers import SentenceTransformer, util
# from transformers import pipeline
# import nltk
# import spacy
# import textstat
# from nltk.translate.bleu_score import sentence_bleu
# from nltk.tokenize import word_tokenize
# 
# nltk.download('punkt')
# nltk.download('averaged_perceptron_tagger')
# nltk.download('maxent_ne_chunker')
# nltk.download('words')
# 
# genai.configure(api_key="AIzaSyCs5BNWAUVyOrdHAEYvmNmh9L2qMHK4dEY")
# spacy_model = spacy.load("en_core_web_sm")
# sentiment_pipeline = pipeline("sentiment-analysis")
# semantic_model = SentenceTransformer("all-MiniLM-L6-v2")
# 
# 
# def generate_gemini_response(prompt):
#     try:
#         model = genai.GenerativeModel("gemini-2.5-flash-preview-05-20")
#         prompt_moderated= f"Constraints: Preserve all named entities (like names of people, places, companies) exactly as they appear. Do not alter or remove them. Return only the rewritten paragraph. Return only **one** version of the rewritten paragraph. Do not include multiple options or any extra commentary:\n\n{prompt}"
#         response = model.generate_content(prompt_moderated)
#         return response.text.strip()
#     except Exception as e:
#         return f"[Error from Gemini]: {e}"
# 
# 
# class BaseStyleAgent:
#     def __init__(self, name):
#         self.name = name
# 
#     def transform(self, text):
#         raise NotImplementedError
# 
# 
# class GenZAgent(BaseStyleAgent):
#     def transform(self, text):
#         prompt = f"Rewrite this paragraph in heavy Gen Z slang with emojis. Only return the rewritten paragraph. No extra text or commentary:\n\n{text}"
#         return generate_gemini_response(prompt)
# 
# 
# class ShakespeareAgent(BaseStyleAgent):
#     def transform(self, text):
#         prompt = f"Rewrite this paragraph using highly Shakespearean English. Only return the rewritten paragraph. No explanations or headers:\n\n{text}"
#         return generate_gemini_response(prompt)
# 
# 
# class CorporateAgent(BaseStyleAgent):
#     def transform(self, text):
#         prompt = f"Convert this paragraph into a formal, professional corporate email style. Output only the rewritten paragraph. No extra commentary:\n\n{text}"
#         return generate_gemini_response(prompt)
# 
# 
# class NoirDetectiveAgent(BaseStyleAgent):
#     def transform(self, text):
#         prompt = f"Rewrite this paragraph in the voice of a 1940s noir detective. Output only the rewritten paragraph with no extra explanation:\n\n{text}"
#         return generate_gemini_response(prompt)
# 
# 
# class ItalianTranslationAgent(BaseStyleAgent):
#     def transform(self, text):
#         prompt = f"Translate this paragraph to native-level Italian. Return only the translated text. No explanations, no formatting, no multiple versions:\n\n{text}"
#         return generate_gemini_response(prompt)
# 
# 
# class SpanishTranslationAgent(BaseStyleAgent):
#     def transform(self, text):
#         prompt = f"Translate this paragraph to native-level Spanish. Return only the translated text. No extras:\n\n{text}"
#         return generate_gemini_response(prompt)
# 
# 
# class FrenchTranslationAgent(BaseStyleAgent):
#     def transform(self, text):
#         prompt = f"Translate this paragraph to native-level French. Output only the translated paragraph. No headers or multiple outputs:\n\n{text}"
#         return generate_gemini_response(prompt)
# 
# 
# class ItalianToEnglishAgent(BaseStyleAgent):
#     def transform(self, text):
#         prompt = f"Translate this Italian paragraph into plain English. Output only the translated text. No headers or extra commentary:\n\n{text}"
#         return generate_gemini_response(prompt)
# 
# 
# class SpanishToEnglishAgent(BaseStyleAgent):
#     def transform(self, text):
#         prompt = f"Translate this Spanish paragraph into plain English. Only return the translated paragraph:\n\n{text}"
#         return generate_gemini_response(prompt)
# 
# 
# class FrenchToEnglishAgent(BaseStyleAgent):
#     def transform(self, text):
#         prompt = f"Translate this French paragraph into plain English. Output only the translated content. No explanation:\n\n{text}"
#         return generate_gemini_response(prompt)
# 
# 
# def back_translate(text):
#     prompt = f"Convert the following styled or translated text back to clear, plain English. Return only the converted English paragraph:\n\n{text}"
#     return generate_gemini_response(prompt)
# 
# 
# def semantic_similarity(original, back):
#     e1 = semantic_model.encode(original, convert_to_tensor=True)
#     e2 = semantic_model.encode(back, convert_to_tensor=True)
#     return round(util.cos_sim(e1, e2).item(), 4)
# 
# 
# def bleu_score(original, back):
#     return round(sentence_bleu([word_tokenize(original.lower())], word_tokenize(back.lower())), 4)
# 
# 
# def readability_scores(text):
#     return {
#         "Flesch Reading Ease": round(textstat.flesch_reading_ease(text), 2),
#         "Gunning Fog Index": round(textstat.gunning_fog(text), 2)
#     }
# 
# 
# def sentiment_score(text):
#     result = sentiment_pipeline(text)[0]
#     return result['label'], round(result['score'], 4)
# 
# 
# def named_entity_preservation(original, transformed):
#     doc1 = spacy_model(original)
#     doc2 = spacy_model(transformed)
# 
#     ents1 = {(ent.text.strip(), ent.label_) for ent in doc1.ents}
#     ents2 = {(ent.text.strip(), ent.label_) for ent in doc2.ents}
# 
#     if not ents1:
#         return "N/A", "No entities in original."
# 
#     preserved = ents1 & ents2
#     missing = ents1 - ents2
# 
#     preserved_types = {label for _, label in preserved}
#     all_types = {label for _, label in ents1}
# 
#     rate = f"{len(preserved_types)}/{len(all_types)}"
#     detail = {
#         "Preserved Entities": list(preserved),
#         "Missing Entities": list(missing)
#     }
# 
#     return rate, detail
# 
# 
# 
# def app():
#     st.set_page_config("Style Transfer + Metrics Dashboard", layout="centered")
#     st.title("Multilingual Style Transfer & Evaluation Dashboard")
# 
#     agents = {
#         "Shakespearean English": ShakespeareAgent("Shakespeare"),
#         "Corporate Email Style": CorporateAgent("Corporate"),
#         "Noir Detective Style": NoirDetectiveAgent("Noir"),
#         "Gen Z Style": GenZAgent("GenZ"),
#         "Italian Translation": ItalianTranslationAgent("Italian"),
#         "Spanish Translation": SpanishTranslationAgent("Spanish"),
#         "French Translation": FrenchTranslationAgent("French"),
#         "Italian to English": ItalianToEnglishAgent("It-EN"),
#         "Spanish to English": SpanishToEnglishAgent("Es-EN"),
#         "French to English": FrenchToEnglishAgent("Fr-EN")
#     }
# 
#     choice = st.selectbox("Choose Style or Language Transformation:", list(agents.keys()))
#     text = st.text_area("Enter your input text", height=200)
# 
#     if st.button("Stylize / Translate and Analyze"):
#         if not text.strip():
#             st.warning("Enter some text to process.")
#             return
# 
#         agent = agents[choice]
# 
#         with st.spinner("Transforming text..."):
#             styled = agent.transform(text)
# 
#         if "to English" not in choice:
#             with st.spinner("Back Translating..."):
#                 back = back_translate(styled)
#         else:
#             back = text
# 
#         sim_score = semantic_similarity(text, back)
#         bleu = bleu_score(text, back)
#         readability = readability_scores(styled)
#         sent_orig, score_orig = sentiment_score(text)
#         sent_styled, score_styled = sentiment_score(styled)
#         ent_pres_rate, ent_detail = named_entity_preservation(text, styled)
# 
#         st.subheader("Output")
#         st.success(styled)
# 
#         if "to English" not in choice:
#             st.subheader("Back-Translated to English")
#             st.info(back)
# 
#         st.subheader("Evaluation Dashboard")
# 
#         col1, col2 = st.columns(2)
#         with col1:
#             st.metric("Semantic Similarity", sim_score)
#             st.metric("BLEU Score", bleu)
#         with col2:
#             st.metric("Named Entity Match", ent_pres_rate)
#             st.subheader("Named Entity Preservation Detail")
#             st.json(ent_detail)
# 
#         st.subheader("Readability Metrics")
#         st.write(readability)
# 
#         st.subheader("Sentiment Shift")
#         col3, col4 = st.columns(2)
#         with col3:
#             st.metric("Original Sentiment", sent_orig, delta=f"{score_orig}")
#         with col4:
#             st.metric("Styled Sentiment", sent_styled, delta=f"{score_styled}")
# 
# 
# if __name__ == "__main__":
#     app()
#

!ngrok config add-authtoken 2y1h90IDQ09WkydpMkH0V1uwDoY_48ETKKBgkK1u6cGDHcwm2

from pyngrok import ngrok
import subprocess
import threading
import time

ngrok.kill()
def run_streamlit():
    subprocess.call(["streamlit", "run", "app.py", "--server.port=8503",
                     "--server.headless=true", "--server.enableCORS=false"])
thread = threading.Thread(target=run_streamlit)
thread.start()
time.sleep(5)

public_url = ngrok.connect(8503)
print(f"Open your app here: {public_url}")

ngrok.kill()